# Chapter1. 도메인 모델 시작하기
### 1.1 도메인이란? (22~24p)
- 소프트웨어로 해결하고자 하는 문제 영역을 의미한다. = 기능
EX) 온라인 쇼핑몰의 상품조회, 구매, 결제, 배송 등
- 도메인은 여러 하위 도메인을 나뉜다.
- 모든 도메인을 직접 구현하지 않으며, 결제나 배송 등은 외부 업체를 사용하기도 한다.

### 1.2 도메인 전문가와 개발자 간 지식 공유 (25~26p)
- 요구사항을 분석하고 설계하는 것이 중요하다.
- 요구사항을 옳바르게 이해해야 한다.

### 1.3 도메인 모델 (27~29p)
- 특정 도메인을 개념적으로 설명한 것을 의미한다.
- 도메인을 이해하려면 제공하는 기능과 데이터 구성을 파악해야 한다.

### 1.4 도메인 모델 패턴 (30~34p)
- 도메인 모델은 도메인 계층을 객체지향 기법으로 구현하는 패턴을 의미한다. <br>
  객체지향 : 상태와 행위를 가진 객체 + 프로그래밍
- 일반적인 아키텍처 구성은 DB - 인프라스트럭처(외부시스템연동) - 도메인(도메인핵심규칙) - 응용(기능실행) - 표현(사용자와 소통) - 사용자 로 되어있다.
- 개념 모델은 순수하게 문제를 분석한 결과물이다. 따라서, 처음에는 전반적인 틀만 잡아놓고 구현과 수정을 거치면서 완벽한 개념모델로 발전시켜야 한다.

### 1.5 도메인 모델 도출 (35~41p)
- 도메인 모델링을 할때 기본은 핵심 구성요소, 규칙, 기능을 찾는 것이다. 기획의 요구사항에서 부터 확인할 수 있다.
- 문서화는 상위 수준에서 정리한 문서로 빠르게 소프트웨어 전반을 이해하기 위해서이며, 깊게 이해하고 싶을 때는 코드레벨로 내려간다.

### 1.6 엔티티와 밸류 (42~56p)
- 모델은 엔티티와 밸류(값)으로 구분할 수 있다.
- 엔티티의 특징은 고유한 식별자를 가지고 있다는 것이다. 각 엔티티는 서로 다른 식별자를 갖는다.<br>
  식별자를 생성하는 방법은 특정규칙, UUID, 자동증가값 등이 있다.<br>
  자동증가값은 DB 에 들어가기전에는 그 값을 알 수 없다. (DB 테이블에 입력되어야 사용이 가능하다)
- 밸류타입은 개념적으로 완전한 하나를 표현할 때 사용한다. EX) Address 밸류타입 -> zipcode, address1, address2 (필드값)<br>
  밸류타입은 클래스형태로 되어있기 때문에 기능을 추가할 수 있다.<br>
  밸류타입을 불변하게 만들면 안전한 코드를 작성할 수 있다.<br>
- 도메인 모델에는 Set 메서드를 넣지 않는다.<br>
  set 메서드는 도메인의 핵심 개념이나 의도를 코드에서 사라지게 한다.<br>
  생성자를 통해 주입시점에 데이터가 올바른지 확인하는 것이 좋다.<br>
  어디에서든 변경이 가능하기 때문에, API 에 관련한 문제를 일으키기도 한다.
  
### 1.7 도메인 용어와 유비쿼터스 언어(57~59p)
- 코드를 작성할 때 도메인 용어를 사용하는 것은 매우 중요하다. 의미를 해석하는 시간을 줄여준다

# Chapter2. 아키텍처 개요
### 2.1 네개의 영역(62~64p)
- 아키텍처를 설계할 때 전형적인 4가지는 표현,응용,도메인,인프라스트럭처 이다.<br>
  표현영역 : 사용자의 요청을 해석해서 응용 서비스에 전달하고 이후 결과를 전달받아 사용자에게 응답한다.<br>
  응용영역 : 사용자에게 제공해야할 기능을 의미한다.<br>
  도메인영역 : 엔티티와 밸류를 가지고 있는 영역<br>
  인프라스트럭처 : 구현기술을 다루는 것을 의미한다. ex) RDBMS 연동, API 호출 등 

### 2.2 계충 구조 아키텍처(65~69p)
- 표현 -> 응용 -> 도메인 -> 인프라스트럭처 구조가 일반적인데, 상위에서 하위로 의존하지만 반대로 의존하지 않는다<br>
- 인프라스트럭처에 의존하면 테스트 구현 및 기능확장이 어려운데, 이러한 점은 DIP 로 보완할 수 있다.

### 2.3 DIP - 추상화한 인터페이스(70~79p)
- 고수준모듈 : 의미 있는 단일 기능을 제공하는 모듈. 여러 저수준모듈로 이루어져 있다.
- 저수준모듈 : 여러 하위기능을 의미
- 고수준 모듈이 저수준 모듈을 사용하게 되면 테스트와 추가 변형이 어렵다는 단점이 있다.<br>
  이러한 점을 해결하기 위해 저수준 모듈이 고수준 모듈을 의존하도록 바꾸는데 추상화한 인터페이스를 사용한다.
  인터페이스에 의존하게 되면, 저수준 객체가 변경되더라도 고수준 모듈은 변경할 필요가 없다.
```
    RuleDiscounter ruleDiscounter = new DroolsRuleDiscounter();
    CalulateDiscountService discountService = new CalulateDiscountService(ruleDiscounter);

    RuleDiscounter ruleDiscounter = new SimpleRuleDiscounter();
    CalulateDiscountService discountService = new CalulateDiscountService(ruleDiscounter);
 ``` 
- 인프라스트럭처는 구현 기술을 다루는 저수준 모듈이고 응용,도메인 영역은 고수준 모듈이다.

### 2.4 도메인 영역의 주요 구성요소(80~89p)
엔티티(Entity) : 고유 식별자를 갖는 객체이며 데이터를 포함한 기능을 제공한다. ex) 주문, 회원, 상품 <br>
밸류(Value) : 하나인 값을 표현할 때 사용한다. ex) Address <br>
애그리거트(Aggregate) : 엔티티와 밸류를 하나로 묶은 것 ex) 주문 애그리거트 <br>
리포지토리(Repository) : 도메인 모델의 영속성 처리 ex) 데이터베이스 <br>
도메인 서비스(Domain Service) : 도메인 로직이 여러 엔티티와 밸류를 필요로 하면 도메인 서비스에서 로직을 실행한다 ex)할인 계산 금액 
- DB 테이블 엔티티와 도메인 테이블 엔티티의 차이점은 도메인 기능을 추가적으로 제공하는 여부에 있다.
- 애그리거트는 도메인 모델에서 전체 구조를 이해하는데 도움을 준다. (군집단위로 파악할 수 있다)
- Repository는 서비스에서 사용한다. 따라서, Repository에서는 서비스에서 사용할 메서드를 제공한다.

### 2.5 요청 처리 흐름(90~91p)
- 사용자가 애플리케이션에 기능 요청을 하면 가장 먼저 표현 영역(Controller) 가 받으며 문제가 없으면 서비스로 기능을 위임한다.
- 서비스는 도메인 상태를 변경하기 때문에 저장소에 올바르게 반영되도록 트랜잭션을 관리해야 한다 ex) @Transactional <br>
  조회와 같이 상태변화가 없을 경우에는 따로 관리하지 않는다.
  
### 2.6 인프라스트럭처 개요(92~93p) 
- 인프라스트럭처는 표현,응용,도메인 영역을 지원한다. ex) 트랜잭션 등과 같은 보조기술, 구현기술을 지원
```
  @Entity
  @Table(name="ORDER")
  public class Order {
  }
```
### 2.7 모듈 구성(94~96p)
- 패키지 구성에는 규칙이 존재하지 않지만, 하나의 패키지에 많은 클래스가 몰려있으면 복잡해진다.
- 프로젝트 구조에 맞는 적절한 패키지 구조를 찾는 것이 바람직하다.

# Chapter3. 애그리거트
### 3.1 애그리거트(98~102p)
- 복잡한 도메인을 이해하고 한눈에 보기 위해서 일관성있게 하나의 군으로 표현하는 방법을 애거리거트라고 한다. ex) 주문, 결제, 회원 등
- 애그리거트는 경계를 갖는다 (다른 애그리거트를 관리하지 않는다)

### 3.2 애그리거트 루트(103~111p)
- 모든 객체가 일관성을 유지하려면 애그리거트를 관리하는 주체를 애그리거트 루트 엔티티라고 한다.
- 하나의 애그리거트에 있는 객체는 모두 정상인 상태이어야 한다. ex) 상품가격, 주문개수 ==> 상품가격 x 주문개수 = 총가격
- 외부에서 애그리거트에 속한 객체를 직접 변경하면 안된다 (set 사용 지양)
- 한 트랜잭션에서는 한 개의 트랜잭션만 수정하는 것이 좋다. 다른 애그리거트에 의존하게 되면 결합도가 높아지기 때문이다.<br>
  2개 이상의 변경이 필요하면, 서비스 로직에서 구현하자.

### 3.3 리포지터리와 애그리거트(112~113p)
- 애그리거트의 상태가 변경되면 필수적으로 저장소에 저장해야 한다.

### 3.4 ID를 이용한 애그리거트 참조(114~120p)
- 애그리거트 간의 참조는 필드를 통해 쉽게 구현할 수 있지만 성능저하 가능성 및 확장의 어려움이 따른다<br>
  ex) order.getOrderer().getMember().getName() -> 주문을 통해 주문한 회원의 이름 조회
- 다른 애그리거트에 접근할 수 있으면 다른 애그리거트의 상태를 변경할 수 있어, 편리함을 오용할 수 있다.

### 3.5 애그리거트 간 집합 연관(121~124p)
- 1:N / N:1 / N:M 관계에 있어서 요구사항을 잘 분석해 집합 연관의 존재 유무를 파악해야 한다.<br>
- N:M (다대다) 관계는 유지보수 및 확장이 불리해 지양하며, 중간 테이블을 따로 생성해 관리하는 것을 지향한다.

### 3.6 애그리거트를 팩토리로 사용하기(125~127p)
- 팩토리로 다른 애그리거트에서 사용하면 서비스에서 중요로직이 노출되지 않아도 되며, 유지보수 시 팩토리 클래스만 변경하면 되고, 응용 서비스는 영향을 받지 않는다

# Chapter4. 리포지터리와 모델 구현 - JPA로 설명
### 4.1 JPA를 이용한 리포지터리 구현(130~135p)
- 인터페이스는 도메인영역에 속하고, 구현한 리포지토리는 인프라스트럭처 영역에 속한다
- 스프링 데이터 JPA 를 사용하면 기본적인 저장, 조회, 삭제 등은 기본제공해준다.
- Update 기능은 따로 생성하지 않는다. JPA는 트랜잭션 안에서 변경한 데이터는 자동으로 DB에 저장한다.

### 4.2 스프링 데이터 JPA를 이용한 리포지터리 구현(136~138p)
- 스프링 데이터 JPA 에서 지정한 규칙에 맞는 인터페이스를 정의하면 리포지터리를 구현한 객체를 알아서 만들어서 스프링 빈으로 등록해준다.
- extends JpaRepository(T타입, ID) 를 사용해 리포지토리 인터페이스에 상속한다.

### 4.3 매핑구현(139~161p)
- 애그리거트 루트는 엔티티이므로 @Entity 로 매핑한다.
- 밸류 타입은 @Embeddable로 매핑하며 밸류 타입의 프로퍼티는 @Embedded로 매핑한다.
- 기본생성자는 필수로 제공해야 한다. 다른 코드에서 생성하지 못하도록 최소한의 범위인 Protected 로 제한한다.
``` 
@Entity
public class Order {
  @Embedded
  private ShippingInfo shippinginfo;
}

@Embeddable
public class ShippingInfo {
  @Embedded
  private Address address;
}
```
- set 메서드는 지양한다. 캡슐화를 깨는 원인이다.
- 밸류 매핑처리는 AttributeConverter 인터페이스를 구현해 해결할 수 있다. ex) 밸류 객체 -> JSON 으로 DB 에 저장해야할 때
- JPA 에서 식별자 타입은 Serializable 타입이어야 하므로, 식별자로 사용할 밸류 타입은 Serializable 인터페이스를 상속받아야 한다.
```
식별자를 밸류 타입으로 만들 수도 있다.
@Entity
public class Order {
  @EmbeddedId
  private OrderNo number;
  ...
}

@Embeddable
public class OrderNo implements Serializable {
  private String number;
}
```
### 4.4 에그리거트 로딩(162~165p)
- 즉시로딩 방식(EAGER)로 설정하면 애그리거트 루트를 로딩하는 시점에 애그르거트에 속한 모든 객체를 가져올 수 있다.<br>
  데이터가 커질수록 이러한 방식은 부하의 문제가 있기 때문에 검토 후 도입해야 한다 <br>
  -> 지연로딩 방식(Lazy) 방식을 기본으로 설정하고 튜닝을 진행하자.

### 4.5 애그러트의 영속성 전파(166p)
- 애그리거트의 루트를 조회할 때 뿐만 아니라, 저장 및 삭제 할때도 하나로 처리해야한다
- Cascade. 옵션을 사용한다.

### 4.6 식별자 생성 기능(167~169p)
- 식별자의 생성은 사용자가 직접 / 도메인 로직으로 생성 / 일련번호 사용 중 1가지를 사용한다.

### 4.7 도메인 구현과 DIP(170~172p)
- DIP 에서 가장 중요한 것은 구현체가 아닌 추상화(인터페이스)에 의존하는 것이다.

# Chapter5. 스프링 데이터 JPA를 이용한 조회 기능
### 5.1 시작에 앞서(174p)
- CQRS는 명령모델과 조회모델을 분리하는 패턴이다. (Command / Query)<br>
  명령모델 : 상태를 변경하는 기능 구현 / 조회모델 : 데이터를 조회하는 기능

### 5.2 검색을 위한 스펙 ~ 5.5 스펙 조합 (175~184p)
- 검색 조건이 다양하게 되면 스펙(Specification) 을 사용하지만, 해당 책에서는 스프링 데이터 JPA 를 사용.
- 이후 진행 예정.

### 5.6 정렬 지정하기 (185~186p)
- 스프링데이터 JPA 에서는 두 가지 방법으로 정렬을 지정할 수 있다.<br>
  1. 메서드 이름이 OrderBy를 사용해서 정렬 기준 지정<br>
  2. Sort를 인자로 전달
```
List<Product> findByProductNameOrderByProductId(String productName)
List<Product> findByProductName(String productName, Sort sort)
```

### 5.7 페이징 처리하기 (187~189p)
- JPA 를 이용하면 페이징 처리를 간단히 구현할 수 있다.
```
List<Product> findAll(Pageable pageable);
PageRequest pageReq = PageRequest.of(1,10);
(페이지번호, 페이지크기)
```
- 메서드의 리턴타입이 Page일 경우 COUNT(데이터개수) 를 같이 구한다.

### 5.8 스펙 조합을 위한 스펙 빌더 클래스 (190~192p)
- if 조건문이 많을 때 SpecBuilder 클래스를 이용하면 깔끔하게 구현할 수 있다. -> 필요할 때 검색해보기

### 5.9 동적 인스턴스 생성 (193~194p)
- JPA는 객체를 동적으로 생성할 수 있다.
- Dto 클래스로 반환을 받고 싶으면 new 오퍼레이션을 이용해야 한다.
```
@Query("select new com.myshop.---.---.dto.memberdto") - 예시
```

### 5.10 하이버네이트 @Subselect 사용(195~198p)
- 쿼리 결과를 @Entity로 매핑할 수 있는 기능 -> 필요할 때 검색해보기

# Chapter6. 응용 서비스와 표현 영역
### 6.1 표현 영역과 응용 영역(200~201p)
- 사용자에게 기능을 제공하려면 도메인과 사용자를 연결해 줄 표현, 응용 영역이 필요하다

### 6.2 응용 서비스의 역할(202~206p)
- 응용 서비스는 사용자가 요청한 기능을 실행한다.
- 응용 서비스가 복잡하다면, 도메인 로직의 일부를 구현하고 있을 수 있다.
- 트랜잭션 처리를 담당한다. 일관성이 깨지지 않도록 해준다.
```
@Transaction -> DB 상 변화가 있을 때 사용
@Transactional(readOnly = true) -> 조회 시 사용하면 약간의 성능 향상
```
- 도메인로직을 넣지 않는다<br>
  1. 코드의 응집성이 떨어진다<br>
  2. 여러 응용 서비스에서 동일한 도메인 로직을 구현할 가능성이 높다 -> 변경의 용이성이 떨어진다.<br>

### 6.3 응용 서비스의 구현(207~217p)
- 응용 서비스는 크기(로직량)를 판단하여 분리할지 통합으로 구현할지 정하는 것이 좋다.
- 응용 서비스의 인터페이스는 구현체가 여러개일 때 사용하는 것이 좋으며, 1개라면 불필요하다.
- 파라미터로 전달받는 값은 Dto 클래스를 따로 만드는 것이 편리하다.
- 응용서비스는 표현 영역에 의존하지 않는것이 좋다 -> 테스트 시 불편함, 리팩토링의 번거로움

### 6.4 표현 영역(218~220p)
- 표현 영역의 책임과 역할<br>
  1. 시스템을 사용할 수 있는 흐름을 제공하고 제어
  2. 요청을 알맞은 응용 서비스에 전달하고 결과를 사용자에게 제공
  3. 세션 관리
  
### 6.5 값 검증(221~226p)
- 값 검증은 보통 서비스 레이어에서 처리한다. 
- 논리적인 검증 또한 서비스 레이어에서 처리한다.

### 6.6 권한검사(227~230p)
- 스프링 시큐리티와 같은 프레임워크를 사용해서 권한에 대한 관리를 유연하고 확장 가능한 형태로 관리한다.
- 컨트롤러에서 서블릿 필터를 이용해서 접근할 수 있는 권한을 설정할 수 있다.
```
@GetMapping("/admin/members") 
@PreAuthorize("hasAnyRole('ADMIN')") 
@ResponseStatus(HttpStatus.OK)
public List<MemberResponse> memberFindAll() {
    return memberService.findAll();
}
```

### 6.7 조회 전용 기능과 응용 서비스(231~232p)
- 조회 전용 서비스에서는 트랜잭션을 사용하지 않아도 된다.

# Chapter7. 도메인 서비스
### 7.1 여러 애그리거트가 필요한 기능(234~236p)
- 결제 금액 계산 로직처럼 애러 애그리거트가 필요한 경우에는 상품,주문,할인 등 어느 도메인에 로직을 넣을지 복잡한 경우가 있다.<br>
  어느 한 곳에 억지로 넣게되면 도메인의 책임을 벗어나기 때문에 복잡하고 수정이 어렵게 만든다.<br>
  -> 도메인 기능을 별도 서비스로 구현하는 방법을 검토하는 것이 좋다.

### 7.2 도메인 서비스(237~243p)
- 도메인 서비스는 여러 애그리거트가 필요한 계산로직 이나, 외부 시스템 연동이 필요한 로직에 사용한다.
- 도메인 서비스를 따로 만들고, 필요한 애그리거트에서 사용하도록 설계한다.
```
// 도메인 서비스 
public class DiscountCalculationService { 
... 
}

//사용
public class OrderService {
  private DiscountCalculationService discountCalculationService;
  ...
}
```
- 특정 기능이 애그리거트의 상태를 변경하거나 계산한다면 도메인 로직으로 판단한다.

# Chapter8. 애그리거트 트랜잭션 관리 - 재학습필요
### 8.1 애그리거트와 트랜잭션(246~247p)
- 운영자는 배송 상태를 바꾸려고 하고, 구매자는 배송지 정보를 바꾸는 상황이라고 가정한다.<br>
  애그리거트의 일관성이 깨지게 된다. 이러한 상황을 막기 위해서는 아래와 같은 방법으로 해결해야 한다.<br>
  1. 운영자가 배송지 정보를 수정하는 동안, 고객이 접근하지 못하도록 막는다.<br>
  2. 배송지 정보를 조회한 이후에 고객이 정보를 변경하면, 운영자가 다시 조회한 후 수정하도록 한다.

### 8.2 선점 잠금(248~252p)
- 먼저 애그리거트를 선점하 스레드의 작업이 끝나기 전까지 다른 스레드가 접근하지 못하도록 하는 것을 의미한다.
- 애그리거트에 대한 잠금을 설정하고 해제할 때 까지 블로킹된다.<br>
  수정 후 트랜잭션을 커밋하면 잠금을 해제한다.<br>
  이후 다른 스레드가 작업을 진행한다.
```
@Lock(LockModeType.PESSIMISTIC_WRITE) // 잠금모드
```
- 선점 잠금을 사용할 때는 교착상태를 주의해야 한다.

### 8.3 비선점 잠금(253~262p)
- 동시에 접근하는 것을 막는대신, 변경한 데이터를 실제 DBMS에 반영하는 시점에 변경 가능 여부를 확인하는 방식을 의미한다.

### 8.4 오프라인 선점 잠금(263~273p)
- 더 엄격하게 데이털 충돌을 막기 위해서는 누군가 수정할 때, 다른 사람이 아예 화면을 실행하지 못하게 할 수 있다.
- 여러 트랜잭션에 걸쳐 동시 변경을 막을 수 있다.

# Chapter9. 도메인 모델과 바운디드 
### 9.1 도메인 모델과 경계(276~277p)
- 한 개의 모델로 여러 하위 도메인을 모두 표현하려고 하면 일치하지 않을 확률이 높다.

### 9.2 바운디드 컨텍스트(278~280p)
- 바운디드 컨텍스트(경계를 갖는 컨텍스트(문맥)) 는 용어를 기준으로 구분한다.
- 여러 하위 도메인을 하나의 바운디드 컨텍스트에서 개발할때는 하위 도메인의 모델이 섞이지 않도록 해야한다.<br>
  하위 도메인별로 기능을 확장하기 어렵게 되는 원인이 된다.

### 9.3 바운디드 컨텍스트 구현(281~284p)
- 바운디드 컨텍스트는 도메인 기능을 제공하는 데 필요한 모든 요소를 포함한다.
- CQRS(Command Query Responsibility Segregation) -> 상태를 변경하는 명령 기능과 내용을 조회하는 쿼리 기능을 위한 모델을 구분해라.

### 9.4 바운디드 컨텍스트 간 통합(285~292p) - 재학습필요

### 9.5 바운디드 컨텍스트 간 관계(293~296p)
- 바운디드 컨텍스트는 어떤 방법으로든 연결을 하고 있는데 대표적으로 REST API 가 있다.
- 상품 카탈로그에서 상품 추천목록을 볼 수 있다고 예시를 들어보자.<br>
  카탈로그 바운디드 컨텍스트 (하류) ------ (상류) 추천 바운디드 컨텍스트<br>
  카탈로그에서 추천 서비스를 사용한다 -> 하류 컴포넌트는 상류 컴포넌트에 의존한다. 
- 상류에서 여러 API 를 만들고 하류에서 사용하는 것을 호스트 서비스 라고 한다. EX) 검색 -> 블로그,카페,게시판 등등

### 9.6 컨텍스트 맵(297~298p)
- 전체 비즈니스를 나타내는 지도를 의미한다.

# Chapter10. 












