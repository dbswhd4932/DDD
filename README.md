# Chapter1. 도메인 모델 시작하기
### 1.1 도메인이란? (22~24p)
- 소프트웨어로 해결하고자 하는 문제 영역을 의미한다. = 기능
EX) 온라인 쇼핑몰의 상품조회, 구매, 결제, 배송 등
- 도메인은 여러 하위 도메인을 나뉜다.
- 모든 도메인을 직접 구현하지 않으며, 결제나 배송 등은 외부 업체를 사용하기도 한다.

### 1.2 도메인 전문가와 개발자 간 지식 공유 (25~26p)
- 요구사항을 분석하고 설계하는 것이 중요하다.
- 요구사항을 옳바르게 이해해야 한다.

### 1.3 도메인 모델 (27~29p)
- 특정 도메인을 개념적으로 설명한 것을 의미한다.
- 도메인을 이해하려면 제공하는 기능과 데이터 구성을 파악해야 한다.

### 1.4 도메인 모델 패턴 (30~34p)
- 도메인 모델은 도메인 계층을 객체지향 기법으로 구현하는 패턴을 의미한다. <br>
  객체지향 : 상태와 행위를 가진 객체 + 프로그래밍
- 일반적인 아키텍처 구성은 DB - 인프라스트럭처(외부시스템연동) - 도메인(도메인핵심규칙) - 응용(기능실행) - 표현(사용자와 소통) - 사용자 로 되어있다.
- 개념 모델은 순수하게 문제를 분석한 결과물이다. 따라서, 처음에는 전반적인 틀만 잡아놓고 구현과 수정을 거치면서 완벽한 개념모델로 발전시켜야 한다.

### 1.5 도메인 모델 도출 (35~41p)
- 도메인 모델링을 할때 기본은 핵심 구성요소, 규칙, 기능을 찾는 것이다. 기획의 요구사항에서 부터 확인할 수 있다.
- 문서화는 상위 수준에서 정리한 문서로 빠르게 소프트웨어 전반을 이해하기 위해서이며, 깊게 이해하고 싶을 때는 코드레벨로 내려간다.

### 1.6 엔티티와 밸류 (42~56p)
- 모델은 엔티티와 밸류(값)으로 구분할 수 있다.
- 엔티티의 특징은 고유한 식별자를 가지고 있다는 것이다. 각 엔티티는 서로 다른 식별자를 갖는다.<br>
  식별자를 생성하는 방법은 특정규칙, UUID, 자동증가값 등이 있다.<br>
  자동증가값은 DB 에 들어가기전에는 그 값을 알 수 없다. (DB 테이블에 입력되어야 사용이 가능하다)
- 밸류타입은 개념적으로 완전한 하나를 표현할 때 사용한다. EX) Address 밸류타입 -> zipcode, address1, address2 (필드값)<br>
  밸류타입은 클래스형태로 되어있기 때문에 기능을 추가할 수 있다.<br>
  밸류타입을 불변하게 만들면 안전한 코드를 작성할 수 있다.<br>
- 도메인 모델에는 Set 메서드를 넣지 않는다.<br>
  set 메서드는 도메인의 핵심 개념이나 의도를 코드에서 사라지게 한다.<br>
  생성자를 통해 주입시점에 데이터가 올바른지 확인하는 것이 좋다.<br>
  어디에서든 변경이 가능하기 때문에, API 에 관련한 문제를 일으키기도 한다.
  
### 1.7 도메인 용어와 유비쿼터스 언어(57~59p)
- 코드를 작성할 때 도메인 용어를 사용하는 것은 매우 중요하다. 의미를 해석하는 시간을 줄여준다

# Chapter2. 아키텍처 개요
### 2.1 네개의 영역(62~64p)
- 아키텍처를 설계할 때 전형적인 4가지는 표현,응용,도메인,인프라스트럭처 이다.<br>
  표현영역 : 사용자의 요청을 해석해서 응용 서비스에 전달하고 이후 결과를 전달받아 사용자에게 응답한다.<br>
  응용영역 : 사용자에게 제공해야할 기능을 의미한다.<br>
  도메인영역 : 엔티티와 밸류를 가지고 있는 영역<br>
  인프라스트럭처 : 구현기술을 다루는 것을 의미한다. ex) RDBMS 연동, API 호출 등 

### 2.2 계충 구조 아키텍처(65~69p)
- 표현 -> 응용 -> 도메인 -> 인프라스트럭처 구조가 일반적인데, 상위에서 하위로 의존하지만 반대로 의존하지 않는다<br>
- 인프라스트럭처에 의존하면 테스트 구현 및 기능확장이 어려운데, 이러한 점은 DIP 로 보완할 수 있다.

### 2.3 DIP - 추상화한 인터페이스(70~79p)
- 고수준모듈 : 의미 있는 단일 기능을 제공하는 모듈. 여러 저수준모듈로 이루어져 있다.
- 저수준모듈 : 여러 하위기능을 의미
- 고수준 모듈이 저수준 모듈을 사용하게 되면 테스트와 추가 변형이 어렵다는 단점이 있다.<br>
  이러한 점을 해결하기 위해 저수준 모듈이 고수준 모듈을 의존하도록 바꾸는데 추상화한 인터페이스를 사용한다.
  인터페이스에 의존하게 되면, 저수준 객체가 변경되더라도 고수준 모듈은 변경할 필요가 없다.
```
    RuleDiscounter ruleDiscounter = new DroolsRuleDiscounter();
    CalulateDiscountService discountService = new CalulateDiscountService(ruleDiscounter);

    RuleDiscounter ruleDiscounter = new SimpleRuleDiscounter();
    CalulateDiscountService discountService = new CalulateDiscountService(ruleDiscounter);
 ``` 
- 인프라스트럭처는 구현 기술을 다루는 저수준 모듈이고 응용,도메인 영역은 고수준 모듈이다.

### 2.4 도메인 영역의 주요 구성요소(80~89p)
엔티티(Entity) : 고유 식별자를 갖는 객체이며 데이터를 포함한 기능을 제공한다. ex) 주문, 회원, 상품 <br>
밸류(Value) : 하나인 값을 표현할 때 사용한다. ex) Address <br>
애그리거트(Aggregate) : 엔티티와 밸류를 하나로 묶은 것 ex) 주문 애그리거트 <br>
리포지토리(Repository) : 도메인 모델의 영속성 처리 ex) 데이터베이스 <br>
도메인 서비스(Domain Service) : 도메인 로직이 여러 엔티티와 밸류를 필요로 하면 도메인 서비스에서 로직을 실행한다 ex)할인 계산 금액 
- DB 테이블 엔티티와 도메인 테이블 엔티티의 차이점은 도메인 기능을 추가적으로 제공하는 여부에 있다.
- 애그리거트는 도메인 모델에서 전체 구조를 이해하는데 도움을 준다. (군집단위로 파악할 수 있다)
- Repository는 서비스에서 사용한다. 따라서, Repository에서는 서비스에서 사용할 메서드를 제공한다.

### 2.5 요청 처리 흐름(90~91p)
- 사용자가 애플리케이션에 기능 요청을 하면 가장 먼저 표현 영역(Controller) 가 받으며 문제가 없으면 서비스로 기능을 위임한다.
- 서비스는 도메인 상태를 변경하기 때문에 저장소에 올바르게 반영되도록 트랜잭션을 관리해야 한다 ex) @Transactional <br>
  조회와 같이 상태변화가 없을 경우에는 따로 관리하지 않는다.
  
### 2.6 인프라스트럭처 개요(92~93p) 
- 인프라스트럭처는 표현,응용,도메인 영역을 지원한다. ex) 트랜잭션 등과 같은 보조기술, 구현기술을 지원
```
  @Entity
  @Table(name="ORDER")
  public class Order {
  }
```
### 2.7 모듈 구성(94~96p)
- 패키지 구성에는 규칙이 존재하지 않지만, 하나의 패키지에 많은 클래스가 몰려있으면 복잡해진다.
- 프로젝트 구조에 맞는 적절한 패키지 구조를 찾는 것이 바람직하다.

# Chapter3. 애그리거트
### 3.1 애그리거트(98~102p)
- 복잡한 도메인을 이해하고 한눈에 보기 위해서 일관성있게 하나의 군으로 표현하는 방법을 애거리거트라고 한다. ex) 주문, 결제, 회원 등
- 애그리거트는 경계를 갖는다 (다른 애그리거트를 관리하지 않는다)

### 3.2 애그리거트 루트(103~111p)
- 모든 객체가 일관성을 유지하려면 애그리거트를 관리하는 주체를 애그리거트 루트 엔티티라고 한다.
- 하나의 애그리거트에 있는 객체는 모두 정상인 상태이어야 한다. ex) 상품가격, 주문개수 ==> 상품가격 x 주문개수 = 총가격
- 외부에서 애그리거트에 속한 객체를 직접 변경하면 안된다 (set 사용 지양)
- 한 트랜잭션에서는 한 개의 트랜잭션만 수정하는 것이 좋다. 다른 애그리거트에 의존하게 되면 결합도가 높아지기 때문이다.<br>
  2개 이상의 변경이 필요하면, 서비스 로직에서 구현하자.

### 3.3 리포지터리와 애그리거트(112~113p)
- 애그리거트의 상태가 변경되면 필수적으로 저장소에 저장해야 한다.

### 3.4 ID를 이용한 애그리거트 참조(114~120p)
- 애그리거트 간의 참조는 필드를 통해 쉽게 구현할 수 있지만 성능저하 가능성 및 확장의 어려움이 따른다<br>
  ex) order.getOrderer().getMember().getName() -> 주문을 통해 주문한 회원의 이름 조회
- 다른 애그리거트에 접근할 수 있으면 다른 애그리거트의 상태를 변경할 수 있어, 편리함을 오용할 수 있다.

### 3.5 애그리거트 간 집합 연관(121~124p)
- 1:N / N:1 / N:M 관계에 있어서 요구사항을 잘 분석해 집합 연관의 존재 유무를 파악해야 한다.<br>
- N:M (다대다) 관계는 유지보수 및 확장이 불리해 지양하며, 중간 테이블을 따로 생성해 관리하는 것을 지향한다.

### 3.6 애그리거트를 팩토리로 사용하기(125~127p)
- 팩토리로 다른 애그리거트에서 사용하면 서비스에서 중요로직이 노출되지 않아도 되며, 유지보수 시 팩토리 클래스만 변경하면 되고, 응용 서비스는 영향을 받지 않는다

# Chapter4. 리포지터리와 모델 구현 - JPA로 설명
### 4.1 JPA를 이용한 리포지터리 구현(130~135p)
- 인터페이스는 도메인영역에 속하고, 구현한 리포지토리는 인프라스트럭처 영역에 속한다
- 스프링 데이터 JPA 를 사용하면 기본적인 저장, 조회, 삭제 등은 기본제공해준다.
- Update 기능은 따로 생성하지 않는다. JPA는 트랜잭션 안에서 변경한 데이터는 자동으로 DB에 저장한다.

### 4.2 스프링 데이터 JPA를 이용한 리포지터리 구현(136~138p)
- 스프링 데이터 JPA 에서 지정한 규칙에 맞는 인터페이스를 정의하면 리포지터리를 구현한 객체를 알아서 만들어서 스프링 빈으로 등록해준다.
- extends JpaRepository(T타입, ID) 를 사용해 리포지토리 인터페이스에 상속한다.

### 4.3 매핑구현(139~161p)
- 애그리거트 루트는 엔티티이므로 @Entity 로 매핑한다.
- 밸류 타입은 @Embeddable로 매핑하며 밸류 타입의 프로퍼티는 @Embedded로 매핑한다.
- 기본생성자는 필수로 제공해야 한다. 다른 코드에서 생성하지 못하도록 최소한의 범위인 Protected 로 제한한다.
``` 
@Entity
public class Order {
  @Embedded
  private ShippingInfo shippinginfo;
}

@Embeddable
public class ShippingInfo {
  @Embedded
  private Address address;
}
```
- set 메서드는 지양한다. 캡슐화를 깨는 원인이다.
- 밸류 매핑처리는 AttributeConverter 인터페이스를 구현해 해결할 수 있다. ex) 밸류 객체 -> JSON 으로 DB 에 저장해야할 때
- JPA 에서 식별자 타입은 Serializable 타입이어야 하므로, 식별자로 사용할 밸류 타입은 Serializable 인터페이스를 상속받아야 한다.
```
식별자를 밸류 타입으로 만들 수도 있다.
@Entity
public class Order {
  @EmbeddedId
  private OrderNo number;
  ...
}

@Embeddable
public class OrderNo implements Serializable {
  private String number;
}
```
### 4.4 에그리거트 로딩 
